package gw.vark.enumgen;

import com.google.common.base.Charsets;
import com.google.common.io.Closeables;
import com.google.common.io.Files;
import org.apache.maven.artifact.Artifact;
import org.apache.maven.model.Resource;
import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.MojoFailureException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.project.MavenProject;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.List;
import java.util.Properties;
import java.util.jar.JarEntry;
import java.util.jar.JarInputStream;

/**
 */
@SuppressWarnings("unused")
@Mojo(name = "generate-enums",
        threadSafe = true,
        defaultPhase = LifecyclePhase.GENERATE_SOURCES)
public class GenerateEnums extends AbstractMojo {
  private static final String ENUMERATED_ATTRIBUTE = "org.apache.tools.ant.types.EnumeratedAttribute";
  private static final String CLASS_SUFFIX = ".class";
  private static final String DIRECTORY = "gw" + File.separatorChar + "vark" + File.separatorChar + "enums" + File.separatorChar;

  @Parameter(property = "plugin.artifacts", required = true, readonly = true)
  private List<Artifact> artifacts;

  @Parameter(property = "project", required = true, readonly = true)
  private MavenProject project;

  @Parameter(defaultValue = "${project.build.directory}/generated-sources/varkenums")
  private File generateDirectory;

  @Parameter(defaultValue = "${project.build.directory}/varkenums.timestamp")
  private File timestampsFile;

  @Parameter(property = "enumgen.skip")
  private boolean skip;

  @Parameter(property = "enumgen.force")
  private boolean force;

  private Class<?> enumeratedAttribute;

  @Override
  public void execute() throws MojoExecutionException, MojoFailureException {
    if (skip) {
      getLog().info("Skipping Vark enums generation");
      return;
    }

    try {
      doExecute();
    } catch (IOException e) {
      throw new MojoFailureException("Failed to generate Vark enums", e);
    }

    Resource resource = new Resource();
    resource.setDirectory(generateDirectory.getAbsolutePath());
    project.addResource(resource);
  }

  private void doExecute() throws IOException, MojoExecutionException, MojoFailureException {
    // First, we need to check if we can load EnumeratedAttribute class
    try {
      enumeratedAttribute = Class.forName(ENUMERATED_ATTRIBUTE);
    } catch (ClassNotFoundException e) {
      throw new MojoExecutionException("Cannot load " + ENUMERATED_ATTRIBUTE + " Ant type!");
    }

    Properties timestamps = new Properties();
    if (timestampsFile.exists()) {
      byte[] bytes = Files.toByteArray(timestampsFile);
      timestamps.load(new ByteArrayInputStream(bytes));
    }

    for (Artifact artifact : artifacts) {
      String id = artifact.getId();
      File artifactFile = artifact.getFile();
      if (!artifactFile.exists()) {
        throw new MojoExecutionException("Cannot find artifact file: " + artifactFile);
      }

      String timestamp = timestamps.getProperty(id);
      String lastModified = Long.toString(artifact.getFile().lastModified());
      if (!force && lastModified.equals(timestamp)) {
        getLog().info("Skipping generation for " + id + ", up-to-date.");
        continue;
      }

      processArtifact(artifact);
      timestamps.put(id, lastModified);
    }

    createParents(timestampsFile);
    ByteArrayOutputStream bout = new ByteArrayOutputStream();
    timestamps.store(bout, "Generated by Aardvark enumgen-maven-plugin");
    Files.write(bout.toByteArray(), timestampsFile);
  }

  private void createParents(File file) throws MojoFailureException {
    if (!file.getParentFile().exists() && !file.getParentFile().mkdirs()) {
      throw new MojoFailureException("Cannot create parent directories for " + file);
    }
  }

  private void processArtifact(Artifact artifact)
          throws IOException, MojoExecutionException, MojoFailureException {
    getLog().debug("Checking " + artifact.getId() + " for Ant enums.");

    File file = artifact.getFile();
    if (file.getName().endsWith(".jar")) {
      // JAR file
      InputStream in = new FileInputStream(file);
      boolean threw = true;
      try {
        JarInputStream jin = new JarInputStream(in);
        JarEntry entry;
        while ((entry = jin.getNextJarEntry()) != null) {
          String name = entry.getName();
          if (name.endsWith(CLASS_SUFFIX)) {
            String className =
                    name.substring(0, name.length() - CLASS_SUFFIX.length()).replace('/', '.');
            processClass(className);
          }
        }
        threw = false;
      } finally {
        Closeables.close(in, threw);
      }
    } else if (file.isDirectory()) {
      // Classes directory
    } else {
      // Unknown.
    }
  }

  private void processClass(String className) throws MojoExecutionException, MojoFailureException, IOException {
    Class<?> clazz = null;
    try {
      clazz = Class.forName(className);
    } catch (Throwable t) {
      getLog().warn("Cannot load class " + className + ", ignoring");
    }

    if (clazz != null &&
            enumeratedAttribute.isAssignableFrom(clazz) &&
            !Modifier.isAbstract(clazz.getModifiers())) {

      String wrapper;
      try {
        getLog().info("Generating wrapper for class " + clazz);
        wrapper = generateEnumWrapper(clazz);
      } catch (Exception e) {
        throw new MojoExecutionException("Cannot generate enum for class " + clazz, e);
      }

      String fileName = DIRECTORY + makeName(clazz) + ".gs";
      File actualFile = new File(generateDirectory, fileName);

      createParents(actualFile);
      Files.write(wrapper, actualFile, Charsets.UTF_8);
    }
  }

  private static String generateEnumWrapper(Class<?> clazz) throws Exception {
    Object instance = clazz.newInstance();
    StringBuilder sb = new StringBuilder();
    sb.append("package gw.vark.enums\n")
            .append("\n")
            .append("enum ").append(makeName(clazz)).append(" {\n\n");

    Method m = clazz.getMethod("getValues");
    String[] vals = (String[]) m.invoke(instance);
    for (String val : vals) {
      if (val.equals("")) {
        val = "NoVal";
      }
      sb.append("  ").append(escape(capitalize(val)))
              .append("(\"")
              .append(escapeForGosuStringLiteral(val))
              .append("\")");
      sb.append(",\n");
    }
    sb.append("\n");
    sb.append("  property get Instance() : ").append(clazz.getName()).append(" {\n");
    sb.append("    return ").append(ENUMERATED_ATTRIBUTE).append(".getInstance(");
    sb.append(clazz.getName()).append(", Val) as ").append(clazz.getName()).append("\n");
    sb.append("  }\n\n");
    sb.append("  var _val : String as Val\n\n");
    sb.append("  private construct( s : String ) { Val = s }\n\n");
    sb.append("}\n");
    return sb.toString();
  }

  private static String escape(String string) {
    String s = "";
    char[] charArray = string.toCharArray();
    for (int i = 0, charArrayLength = charArray.length; i < charArrayLength; i++) {
      char c = charArray[i];
      if (i == 0 && !Character.isJavaIdentifierStart(c)) {
        s = "_" + c;
      } else if (!Character.isJavaIdentifierPart(c)) {
        s += "_";
      } else {
        s += c;
      }
    }
    return s;
  }

  private static String capitalize(String str) {
    if (str == null || str.isEmpty()) {
      return str;
    }
    return Character.toTitleCase(str.charAt(0)) + str.substring(1);
  }

  private static String makeName(Class<?> clazz) {
    if (clazz.getEnclosingClass() != null) {
      return makeName(clazz.getEnclosingClass()) + '_' + clazz.getSimpleName();
    }
    return clazz.getSimpleName();
  }

  public static String escapeForGosuStringLiteral(String str) {
    StringBuilder sb = new StringBuilder(str.length());
    for (int i = 0; i < str.length(); i++) {
      sb.append(escapeForGosuStringLiteral(str.charAt(i)));
    }
    return sb.toString();
  }

  public static String escapeForGosuStringLiteral(char ch) {
    switch (ch) {
      case '\b':
        return "\\b";
      case '\f':
        return "\\f";
      case '\n':
        return "\\n";
      case '\r':
        return "\\r";
      case '\t':
        return "\\t";
      case '\'':
        return "\\'";
      case '\"':
        return "\\\"";
      case '\\':
        return "\\\\";
      default:
        return isPrintableAscii(ch)
                ? String.valueOf(ch)
                : String.format("\\u%04x", (int) ch);
    }
  }

  private static boolean isPrintableAscii(char ch) {
    return ch >= ' ' && ch <= '~';
  }
}
